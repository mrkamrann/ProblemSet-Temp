/*
Link: https://leetcode.com/problems/find-products-of-elements-of-big-array/

Julie has a powerful vector for an integer x, which is the shortest sorted vector of powers of two that sum up to x. For example, the powerful vector for 11 is [1, 2, 8].

The vector big_nums is created by concatenating the powerful vectors for every positive integer i in ascending order: 1, 2, 3, and so forth. Thus, big_nums starts as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, ...].

Julie is given a 2D integer matrix queries, where for queries[i] = [from_i, to_i, mod_i] you should calculate (big_nums[from_i] * big_nums[from_i + 1] * ... * big_nums[to_i]) % mod_i.

Return an integer vector answer such that answer[i] is the answer to the ith query.

Create a C++ Function FindProductsOfElements that will return a vector<int> denoting answer such that answer[i] is the answer to the ith query.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<vector<int>> denoting queries

Input Constraints:

The length of queries should be at least 1 and at most 500 inclusive.
Each queries[i] should have exactly 3 elements.
Each from_i should be in the range [0, 10^15] inclusive.
Each to_i should be in the range [from_i, 10^15] inclusive.
Each mod_i should be in the range [1, 10^5] inclusive.

*/

#include <vector>
#include <stdexcept>
#include <cassert>


      std::pair<long long, long long> SumAndCountBitsBeforeValue(long long value) {
        long long bit_sum = 0;
        long long bit_count = 0;
        for (long long bit = 0, power = 1; power < value; bit++, power <<= 1) {
            long long current = (value >> (bit + 1)) << bit;
            current += std::max(0LL, (value % (power << 1)) - power);
            bit_count += current;
            bit_sum += bit * current;
        }
        return {bit_sum, bit_count};
    }

    long long GetValueFromIndex(long long index) {
        index++;
        long long low = 1, high = 1LL << 50;

        while (low < high) {
            long long mid = low + (high - low) / 2;
            if (SumAndCountBitsBeforeValue(mid + 1).second < index) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    long long PrefixSumTillIndex(long long index) {
        long long value = GetValueFromIndex(index);
        std::pair<long long, long long> sum_and_count = SumAndCountBitsBeforeValue(value);

        long long bit_sum = sum_and_count.first;
        long long bit_count = sum_and_count.second;

        if (bit_count < index) {
            for (int bit = 0; bit_count < index; bit++, value >>= 1) {
                bit_sum += bit * (value % 2);
                bit_count += value % 2;
            }
        }
        return bit_sum;
    }


    int Multiply(long long multiplicand, long long multiplier, int modulus) {
        return ((multiplicand % modulus) * (multiplier % modulus)) % modulus;
    }

    int Pow(long long base, long long exponent, int modulus) {
        if (exponent <= 0) {
            return 1 % modulus;
        }
        base %= modulus;
        long long result = 1;
        while (exponent) {
            if (exponent & 1) {
                result = Multiply(result, base, modulus);
            }
            base = Multiply(base, base, modulus);
            exponent >>= 1;
        }
        return result;
    }

    
  
    std::vector<int> FindProductsOfElements(std::vector<std::vector<long long>>& queries) {
        
        if (queries.empty() || queries.size() > 500) {
            throw std::invalid_argument("Queries size must be between 1 and 500 inclusive.");
        }
        for (const std::vector<long long>& query : queries) {
            if (query.size() != 3) {
                throw std::invalid_argument("Each query must contain exactly 3 elements.");
            }
            if (query[0] < 0 || query[0] > 1e15) {
                throw std::invalid_argument("from_i must be in the range [0, 10^15] inclusive.");
            }
            if (query[1] < query[0] || query[1] > 1e15) {
                throw std::invalid_argument("to_i must be in the range [from_i, 10^15] inclusive.");
            }
            if (query[2] < 1 || query[2] > 1e5) {
                throw std::invalid_argument("mod_i must be in the range [1, 100000] inclusive.");
            }
        }

        std::vector<int> result;
        result.reserve(queries.size());

        for (const std::vector<long long>& query : queries) {
            long long prefix_sum_from = PrefixSumTillIndex(query[0]);
            long long prefix_sum_to = PrefixSumTillIndex(query[1] + 1);

            result.push_back(Pow(2, prefix_sum_to - prefix_sum_from, query[2]));
        }

        return result;
    }



int main() {
 
   // TEST
std::vector<std::vector<long long>> queries_1 = {{0, 10, 2}};
std::vector<int> expected_1 = {0};
std::vector<int> result_1 = FindProductsOfElements(queries_1);
assert(result_1 == expected_1);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_2 = {{1, 100, 3}};
std::vector<int> expected_2 = {2};
std::vector<int> result_2 = FindProductsOfElements(queries_2);
assert(result_2 == expected_2);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_3 = {{2, 20, 4}, {5, 50, 6}};
std::vector<int> expected_3 = {0, 4};
std::vector<int> result_3 = FindProductsOfElements(queries_3);
assert(result_3 == expected_3);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_4 = {{10, 1000, 10}};
std::vector<int> expected_4 = {2};
std::vector<int> result_4 = FindProductsOfElements(queries_4);
assert(result_4 == expected_4);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_5 = {{0, 500, 5}, {1, 1000, 10}, {2, 1500, 15}};
std::vector<int> expected_5 = {4,4,1};
std::vector<int> result_5 = FindProductsOfElements(queries_5);
assert(result_5 == expected_5);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_6 = {{100, 10000, 100}};
std::vector<int> expected_6 = {72};
std::vector<int> result_6 = FindProductsOfElements(queries_6);
assert(result_6 == expected_6);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_7 = {{0, 10, 2}, {1, 100, 3}, {1,99,333}};
std::vector<int> expected_7 = {0, 2, 229};
std::vector<int> result_7 = FindProductsOfElements(queries_7);
assert(result_7 == expected_7);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_8 = {{1, 10, 1}, {2, 20, 2}, {3, 30, 3}};
std::vector<int> expected_8 = {0,0,1};
std::vector<int> result_8 = FindProductsOfElements(queries_8);
assert(result_8 == expected_8);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_9 = {{0, 0, 1}};
std::vector<int> expected_9 = {0};
std::vector<int> result_9 = FindProductsOfElements(queries_9);
assert(result_9 == expected_9);
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_10 = {{-1, 10, 2}};
try {
    FindProductsOfElements(queries_10);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_11 = {{10, 5, 2}};
try {
    FindProductsOfElements(queries_11);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_12 = {{0, 10, 0}};
try {
    FindProductsOfElements(queries_12);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_13(501, {0, 10, 2});
try {
    FindProductsOfElements(queries_13);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_14 = {{10000000000000001, 10, 2}};
try {
    FindProductsOfElements(queries_14);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_15 = {{0, 10000000000000001, 2}};
try {
    FindProductsOfElements(queries_15);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_16 = {{0, 10, -2}};
try {
    FindProductsOfElements(queries_16);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END

// TEST
std::vector<std::vector<long long>> queries_17 = {{-1, -10, -2}};
try {
    FindProductsOfElements(queries_17);
    assert(false);
} catch (const std::invalid_argument& e) {
    assert(true);
}
// TEST_END
    return 0;
}
